== Introduction ==

==== Todays Schedule ====

<[block]{Morning}

* Valentin
** Agile Methods
** Unit testing
** Version Control

* Rike
** Unit testing demo
** Subversion demo
** Debugging demo

[block]>

==== Todays Schedule ====

<[block]{Afternoon}

Niko
* General Design Principles
* Object Oriented Programming in Python
* Object Oriented Design Principles
* Design Patterns


[block]>

==== Motivation ====

* Many scientists write code regularly but few have formally been trained to do so
* Best practices can make a lot of difference
* Development methodologies are established in the software engineering industry
* We can learn a lot from them to improve our coding skills

==== Scenarios ====

*  Lone student/scientist

<[center]
    <<<lucky_luke.jpg, scale=0.30>>>
[center]>

*  Small team of scientists, working on a common library
*  Speed of development more important than execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

== Agile methods ==

==== Outline ====

\tableofcontents[currentsection]

==== What is a development methodology ====

Consist of:

* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach

Help answer the following questions:

* How far ahead should I plan?
* What should I prioritize?
* When do I write tests and documentation?

==== The waterfall model, Royce 1970 ====

<[figure][ht]
    <<<Waterfall_model.png, scale=0.25>>>
[figure]>

* Iterative process
* But: very heavyweight
* Not efficient or adaptive

\tiny{The image is licensed under the Creative Commons Attribution 3.0 License. (c) Paul Smith}

==== Agile Methods ====

* Agile methods emerged during the late 90's
* Generic name for set of more specific paradigms
* Set of ''best practices''

* Particularly suited for:
** small teams ( less than 10 people)
** unpredictable or rapidly changing requirements

==== Prominent Features of Agile methods ====

* Minimal planning

* Small development iterations

* Rely heavily on testing

* Promote collaboration and teamwork

* Very adaptive

==== The Basic Agile Workflow ====


<[figure]
    <<<basic_agile_workflow.pdf, scale=0.25>>>
[figure]>

==== Example ====

<[center]
<<<define_test.pdf, scale=0.25>>>

\hspace{10cm}

function @my\_sum@ should return the sum of a list.

[center]>

==== Example ====

<[center]
<<<simplest_version.pdf, scale=0.25>>>


\hspace{10cm}

<[code][style=basic, language=Python]
def my_sum(my_list):
    """ Compute sum of list elements. """
    answer = 0
    for item in my_list:
        answer = answer + item
    return answer
[code]>

[center]>

==== Example ====

<[center]
<<<ensure_test.pdf, scale=0.25>>>

\hspace{10cm}

<[code][style=basic, language=Python]
>>> my_sum(\[1,2,3\]) 
6 
[code]>

[center]>

==== Example ====

<[center]
<<<better_version.pdf, scale=0.25>>>

\hspace{10cm}

<[code][style=basic, language=Python]
def my_sum(my_list):
    """ Compute sum of list elements. """
    return sum(my_list)
[code]>

[center]>

==== Agile methods ====

<[figure][ht]
    <<<dilbert-agile_programming.jpg, scale=0.45>>>
[figure]>


==== Whats Next ====

* Look at tools to support the agile workflow

* Better testing with '''Unit Tests'''

* Keeping track of changes and collaborating with '''Version Control'''

* Additional techniques

== Best Practices ==

=== Unit Testing ===

==== Unit Tests ====

<[block]{Definition of a ''Unit''}
* The smallest testable piece of code
* Example: @my\_sum@
[block]>

* We wish to automate testing of our units
* In python we use the package @unittest@

==== Example ====

<[code][style=basic, language=Python, frame=none]
import unittest

def my_sum(my_list):
    """ Compute sum of list elements. """
    return sum(my_list)

class Test(unittest.TestCase):
    def test_my_sum(self):
        self.assertEqual(my_sum(\[1,2,3\]),6)

if __name__ == "__main__":
    unittest.main()

[code]>

==== Running the Example ====

<[code][style=basic,  frame=none]
% python example-test2.py
.
--------------------------------------------------------
Ran 1 test in 0.000s

OK
[code]>

==== The Basic Agile Workflow - Reloaded ====

<[figure]
    <<<agile_reloaded.pdf, scale=0.25>>>
[figure]>


==== Goals ====

* check code works

* check design works

* catch regression

==== Benefits ====

* Easier to test the whole, if the units work

* Can modify parts, and be sure the rest still works

* Provide examples of how to use code

==== How to test ? ====

* Test with simple (but general) cases, using hard coded solutions
** @sum(3,5) = 5@

* Test general routines with specific ones
** test @polyomial\_expansion(data, degree)@ with @quadratic\_expansion(data)@

* Test special or boundary cases
** test @has\_prefix(string, pfx)@ for @pfx=""@

* Test that meaningful error messages are raised upon corrupt input
** Relevant when writing scientific libraries

(There will be some more concrete example in the second part.)

==== What makes a good test? ====

* independent (of each other, and of user input)

* repeatable (i.e. deterministic)

* self-contained

==== Stuff thats harder to test ====

Probabilistic code
* Use toy examples as validation
* Consider fixing the seed for your pseudo random number generator

Hardware
* use mock up software that behaves like the hardware should

Plots
* (any creative ideas welcome)

==== Test Suits ====

* All unit tests are collected into a test suite

* Execute the entire test suite with a single command

* Can be used to provide reports and statistics

==== Refactoring ====

This is what its called when you write a ''better'' version of your code.

* Re-organisation of your code without changing its function:
** remove duplicates by creating functions and methods
** increase modularity by breaking large code blocks into units
** rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and use the unit tests to check code still works
* Learn how to use automatic refactoring tools to make your life easier


==== Dealing with bugs ====

* Isolate the bug

* Write a unit test to expose the bug

* Fix the code, and ensure the test passes

* Use the test to catch the bug should it reappear

==== Dealing with Bugs ====

<[figure][ht]
    <<<phd_bug.jpg, scale=0.4>>>
[figure]>

==== Introducing new features ====

* Split feature into units

* Use the agile workflow 

* Tests drive the development

* Keep the iterations small 

==== Some last thoughts ====

* Tests increase the confidence that your code works correctly, not only for yourself but also for your reviewers
* Tests are the only way to trust your code
* It might take you a while to get used to the idea, but it will pay off quite rapidly

\hspace{4cm}

* Questions?

=== Version Control ===

==== What is Version Control? ====
<[block]{Problem 1}
"Help my code worked yesterday, but I can't recall what I changed!"
[block]>

<[block]{Problem 2}
"We would like to work together, but we don't know how!"
[block]>

\hspace{6cm}

* Version control is a method to track changes in source code
* Concurrent editing is possible via merging

==== Features ====

* Revert to previous versions

* Document developer effort
** Who changed what, when and why?

* Easy collaboration across the globe

==== What Will We Use ? ====

* Many different systems available

* We will use the de-facto standard:

<[figure][ht]
    <<<Subversion_logo.pdf, scale=0.3>>>
[figure]>

==== Where the Versions are Stored ? ====

<[figure][ht]
    <<<central.pdf, scale=0.25>>>
[figure]>

* '''repository''' is located on a server
* Developers must connect to this server

==== Contents of the Repository ====

<[figure]
    <<<repository.pdf, scale=0.25>>>
[figure]>

==== Basic Version Control Workflow ====

<[figure]
    <<<vc_workflow.pdf, scale=0.25>>>
[figure]>

==== Some last thoughts ====

* Use version control for anything thats text
** Code
** Thesis
** Letters
* We will be using '''centralised''' version control, note there exists also '''decentralised''' version control
* Again, it might take a while to get used to the idea, but it will pay off rapidly.


* Questions

===  Additional techniques ===

==== Additional Techniques ====

* Pair Programming
* Optmization?
* Style and documentation

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observes and instructs
* Switch roles every so often

==== Optimization ====

* Readable code is usually better than fast code
* Only optimize if its absolutely necessary, seriously
* Only optimize your bottlenecks
* ...and identify these using a profiler

Optimizations Strategies for Scientific Python
* replace for loops with array multiplication
* implement bottlenecks in Cython
* parallelize you application and run it on a cluster

==== Coding Style ====

* Adhere to coding conventions (PEP8)
* OR use a consistent style
* Use automated tools to ensure adherence

==== Documentation ====

* When I learnt to program... documentation was of paramount importance
* With concise and clear languages like python this is less so
* Minimum requirement: at least a docstring

==== Other ideas ====

* Use a build system
* If you are unsure how to do something build a prototype to check feasibility
* Use automated testing, and collect statistics
* Use a bug tracker
* Mailinglists and IRC

==== Results ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (German Research Council 1999)

* Increasing pressure to make the source used in publications available

* With unit tested code you need not be embarrassed to publish your code

==== Distributed version control ====

<[figure][ht]
    <<<distributed.pdf, scale=0.19>>>
[figure]>

* Support any workflow ?!


