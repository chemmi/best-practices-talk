== Introduction ==

==== Outline ====

\tableofcontents[currentsection]

==== Modern programming practices and science ====

* Many of us have to routinely write computer programs
* but few of us have been trained to do so
* Good programming practices can make a lot of difference
* Development methodologies have been introduced for the development of commercial software, but we can learn a lot from them about making science

==== Scenarios ====

*  Lone scientist, coding up a model or data  analysis tool for a research project
*  Small team of scientists, working on a  common library
*  The bottleneck is developing speed, not  execution speed
*  Need to try out different ideas:
*  rapid prototyping, re-use code, identify common patterns and use known solutions

==== Requirements for scientific programming ====

* {Every scientific result (especially if important) should be independently reproduced at least internally before publication (DFG, 1999)}
** Translation: there must be guarantees that the source code works as advertised (testing frameworks, pair programming)
* Increasing pressure for making the source code used in publications available online (especially for theoretical papers)
** Translation: you shouldnâ€™t be embarrassed of publishing your code
** Your code must be readable and easily reusable

== Development methodologies ==

==== Outline ====

\tableofcontents[currentsection]


==== What is a development methodology ====

<[block]{Wikipedia Definition}
refers to the framework that is used to structure, plan, and control the process of developing an information system.
[block]>

Help answer the following questions:

* How far ahead should we plan?
* What should we prioritize?
* When do we write tests and documentation?

Consist of:

* A philosophy that giverns the style and approach towards development
* A set of tools and models to support the particular approach

==== The waterfall model, Royce 1970 ====

<[figure][ht]
    <<<Waterfall_model.png, scale=0.25>>>
[figure]>

* Iterative process
* But: very heavyweight
* Not cost efficient

\tiny{This work is licensed under the Creative Commons Attribution 3.0 License. (c) Paul Smith}

==== The spiral model, Beuss 1980 ====

<[figure][ht]
    <<<Spiral_model.png, scale=0.25>>>
[figure]>

* Better, since the ietration cycles are smaller
* Still quite heavyweight and cumbersome

\tiny{This work is public domain. (c) Marc Troy, modified by Wikipedia User Conan.}

==== Xtreme Programming, 1999 Kent Beck, Ward Cunningham, and Ron Jeffries ====

<[figure][ht]
    <<<Xp-loop.png, scale=0.25>>>
[figure]>

* Tight integration cycles
* Very adaptive method
* Relies heavily on testing

\tiny{This work is licensed under the Creative Commons Attribution 3.0 License. (c) Marcel Douwe Dekker}

==== Agile development ====

* Agile methods grew out of their iterative predecessors
* Generic name for set of more specific paradigms
* Most influential eXtreme Programming (XP), 
* Set of best practices, from design of software to development to maintenance
* Particularly suited for small teams ( less than 10 people) facing  unpredictable or rapidly changing requirements (sounds familiar?)

==== The agile manifesto ====

We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:

* Individuals and interactions over processes and tools
* Working software over comprehensive documentation
* Customer collaboration over contract negotiation
* Responding to change over following a plan

That is, while there is value in the items on the right, we value the items on the left more.

== Best Practices ==

==== Outline ====

\tableofcontents[currentsection]

==== What should i use? ====

* All agile methods together suggest an overwhelming number of ideas
* In practice you will not use all (even most)
* Experiment to figure out what works for you
* However, some are '''strongly''' recommended

=== Unit Testing ===

==== Unit Tests ====

* Today, any software without unit tests is considered ''legacy software''
* Tests the ''units'' with a predefined input, to ascertain they return the expected output
* Usually automated so that all unit tests can be executed with a single command

==== Test driven development ====

Make small iterations

* Write the test for a unit first
* Then write the unit
* Lastly make sure all tests pass

This should all happen within one coding session, for example an afternoon.

===== What is a unit? ====

* Units are smallsh chunks of code
* Examples:
** function to compute the euclidian distance
** decimal to binary converter
* I always think of them as the bricks of lego i write for myself

==== Benefits of unit tests ====

* Provide additional confidence that your code works as intended
* Make it much easier to modify the code, and be confident that you didn't break it
* Provide an example of how to use your code to other developers
* If your code is hard to test, this suggests a bad design

==== Examples of unit tests ====

==== Examples of testing frameworks ====

* 'unittest'
* 'nosetest'
* 'doctest'


==== Dealing with bugs ====

* Write a unit test to expose the bug
* Fix the code, and ensure the test passes
* Use the test to identify if the bug reappears

==== Dealing with probabalistic code ====

* Use those toy examples as tests
* Test all ''units'' of the algorithm
* Consider fixing the seed for your PRNG

=== Version Control ===

==== What is version control ====

* Toolkit to track modifications of source code

* Two main paradigms
** Centralised
** Distributed

* How often do you ask yourself the question: "Help my code worked yesterday, but i can't recall what i changed!"

==== Benefits of version control ====

* Revert changes without effort
* Document developer effort
* Easy collaboration across the globe
* Synchronisation

==== Centralised version control ====
<[figure][ht]
    <<<centralised.png>>>
[figure]>

==== Distributed version control ====
<[figure][ht]
    <<<centralised.png, scale=0.5>>>
[figure]>
<[figure][ht]
    <<<distributed1.png, scale=0.5>>>
[figure]>
<[figure][ht]
    <<<distributed2.png, scale=0.5>>>
[figure]>

==== What will we use? ====

* Distributed is more flexible
* Centralised has a shallow learning curve
* Hence we will teach you to use the de-fact centralised standard:
* @subversion@

===  Other techniques ===

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observers and instructs
* Switch roles every so often

==== A note about Optimization ====

* Only optimize if its absolutely necessary
* Only optimize your bottlenecks

==== Refactor all the time ====

* Don't live with broken windows
* If you find yourself copy and pasting code for the second time, refactor and make a function/method
* Simplify your code
* Coding is an itertaive process
* However, don't refactor if its not itching, instead code only what you need

==== Other ideas ====

* Use a build system
* Adhere to coding conventions, or use a consisten style
* Prototype ideas
* Use automated testing, and collect statistics
* Using a bug tracker
