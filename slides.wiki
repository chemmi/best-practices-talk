== Introduction ==

==== Todays Schedule ====

<[block]{Morning}

* Valentin
** Development Methodologies
** Agile Methods
** Unit testing
** Version Control

* Rike
** Unit testing demo
** Subversion demo
** Debugging demo

* Exercise
** Subversion
** Unit Tetsing 

[block]>

==== Todays Schedule ====

<[block]{Afternoon}

* Nico
** Design Principles
** Object Orientation
** Design Patterns

[block]>

==== Outline ====

\tableofcontents[currentsection]

==== Motivation ====

* Most (Almost All?) scientists write programs regularly
* Not many (Almost None?) have been trained to do so
* Often its not just about the raw functionality
* Best practices can make a lot of difference
* Development methodologies are established in the software engineering industry
* We can learn a lot from them to improve our coding skills 

==== Scenarios ====

*  Lone student/scientist
*  Small team of scientists, working on a common library
*  The bottleneck is usually speed of development
*  '''Not''' execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

==== Requirements ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (DFG 1999)
* Hence there must be checks to ensure the code works as advertised

* Increasing pressure to make the source used in publications available
* (especially for theoretical/modelling papers)
* You shouldnâ€™t be embarrassed to publish your code
* (You shouldn't write crappy code that you are embarrassed to publish)
* Your code should be readable and easily reusable
* (But: thats actually quite hard)

== Development methodologies ==

==== Outline ====

\tableofcontents[currentsection]

==== What is a development methodology ====

<[block]{Wikipedia Definition}
refers to the framework that is used to structure, plan, and control the process of developing an information system.
[block]>

Help answer the following questions:

* How far ahead should we plan?
* What should we prioritize?
* When do we write tests and documentation?

Consist of:

* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach

==== The waterfall model, Royce 1970 ====

<[figure][ht]
    <<<Waterfall_model.png, scale=0.25>>>
[figure]>

* Iterative process
* But: very heavyweight
* Not cost efficient


\tiny{The image is licensed under the Creative Commons Attribution 3.0 License. (c) Paul Smith}
==== The spiral model, Beuss 1980 ====

<[figure][ht]
    <<<Spiral_model.png, scale=0.30>>>
[figure]>

* Better, since the iteration cycles are smaller
* Still quite heavyweight and cumbersome

\tiny{The image is public domain. (c) Marc Troy, modified by Wikipedia User Conan.}

==== Xtreme Programming, 1999 Beck, Cunningham, and Jeffries ====

<[figure][ht]
    <<<xp_flow.png, scale=0.5>>>
[figure]>

* Tight integration cycles
* Very adaptive method
* Relies heavily on testing
* Release early and often

==== Agile development ====

* Agile methods grew out of their iterative predecessors
* Generic name for set of more specific paradigms
* XP is the most prominent example
* Can be understood as a set of ''best practices''
* Particularly suited for small teams ( less than 10 people) facing  unpredictable or rapidly changing requirements (sounds familiar?)

==== What should I use? ====

* All agile methods together suggest an overwhelming number of ideas
* In practice you will not use all (even most)
* Experiment to figure out what works for you
* However, some are '''strongly''' recommended, and we will focus on two today:
** Unit Testing
** Version Control
* Its best to adopt these early on, since bad habits will be very hard to break once established


== Best Practices ==

==== Outline ====

\tableofcontents[currentsection]

=== Unit Testing ===

==== Outline ====

\tableofcontents[section=Unit Testing]


==== Unit Tests ====

<[block]{Definition of a ''Unit''}
* The smallest testable piece of code
* A function or a method
[block]>

Tests serve to:
* check code works
* check design works
* catch regression

==== Test driven development ====

<[block]{Make small iterations of:}
* Write the test for a unit first
* Then write the unit itself
* Lastly make sure all tests pass
[block]>

* This should all happen within one coding session

\tiny{(If you can't make this happen, at least write the test after you wrote the code...)}

==== Additional benefits ====

* Ease integration and system testing 
* Much easier to modify code without breaking whats already there
* Provide examples of how to use code
* If your code is hard to test, this might suggests a bad design

==== How to test ? ====

* Test with simple (but general) cases, using hard coded solutions
** @sum(3,5) = 5@

* Test general routines with specific ones
** test @polyomial\_expansion(data, degree)@ with @quadratic\_expansion(data)@

* Test special or boundary cases
** test @has\_prefix(string, pfx)@ for @pfx=""@

* Test that meaningful error messages are raised upon corrupt input
** Relevant when writing scientific libraries

(There will be some more concrete example in the second part.)

==== What makes a good test? ====

* independent (of each other, and of user input)
* repeatable (i.e. deterministic)
* self-contained

==== Dealing with bugs ====

* Isolate the bug (preferably with a debugger)
* Write a unit test to expose the bug
* Fix the code, and ensure the test passes
* Use the test to identify if the bug reappears

==== Stuff thats harder to test ====

Probabalistic code
* Use toy examples as validation
* Test all ''units'' of your algorithm
* Consider fixing the seed for your pseudo random number generator

Hardware
* use a mock up that behaves like the hardware should

Plots
* (any creative ideas welcome)

==== Some last thoughts ====

* Today, any software without unit tests is considered ''legacy software''
* Usually automated so that all unit tests can be executed with a single command
* Tests increase the confidence that your code works correctly, not only for yourself but also for your reviewers
* It might take you a while to get used to the idea, but it will pay off quite rapidly

=== Version Control ===

==== What is version control ====

* Toolkit to track modifications of source code

* Two main paradigms
** Centralised
** Distributed

* How often do you ask yourself the question: "Help my code worked yesterday, but I can't recall what I changed!"

==== Benefits of version control ====

* Revert to previous versions without effort
* Document developer effort
** Who changed what, when and why?
* Easy collaboration across the globe
* Synchronisation

==== Centralised version control ====

<[figure][ht]
    <<<centralised.pdf, scale=0.3>>>
[figure]>

* Central server stores all revisions
* Developers must connect to this server

==== Distributed version control ====

<[figure][ht]
    <<<distributed.pdf, scale=0.19>>>
[figure]>

* Support any workflow ?!


==== What will we use? ====

* Distributed is more flexible
* Centralised has a shallower learning curve
* Hence we will teach you to use the de-facto centralised standard:
* @subversion@

<[figure][ht]
    <<<Subversion_logo.pdf, scale=0.3>>>
[figure]>

(There will be a demo and introduction in the second part)

\hspace{4cm}

\tiny{Subversive comment: If you are interested in distributed version control, checkout \texttt{git}, the stupid content tracker.}

===== Some last thoughts ====

* Use version control for anything thats text
** Code
** Thesis
** Letters

* Again, it might take a while to get used to the idea, but it will pay off rapidly.

===  Other techniques ===

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observes and instructs
* Switch roles every so often

==== Optimization ====

* Readable code is usually better than fast code
* Only optimize if its absolutely necessary, seriously
* Only optimize your bottlenecks
* ...and identify these using a profiler

Optimizations Strategies for Scientific Python
* replace for loops with array multiplication
* implement bottlenecks in Cython
* parallelize you application and run it on a cluster

==== Refactoring ====

* Re-organisation of your code without changing its function:
** remove duplicates by creating functions and methods
** break large code blocks into functions
** rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and make sure the code still works in between
* Learn how to use refactoring tools to make your life easier
* Do it continuously for maximum effect

==== Coding Style ====

* Adhere to coding conventions (PEP8)
* OR use a consistent style
* Use automated tools to ensure adherence

==== Documentation ====

* When I learnt to program... documentation was of paramount importance
* With concise and clear languages like python this is less so
* Minimum requirement: at least a docstring

==== Other ideas ====

* Use a build system
* If you are unsure how to do something build a prototype to check feasibility
* Use automated testing, and collect statistics
* Use a bug tracker
* Mailinglists and IRC


